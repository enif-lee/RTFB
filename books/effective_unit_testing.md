## Part 1. 기반 다지기

### Chapter 3. 테스트 더블

#### 의미

테스트 더블은 테스트를 실행하기 위한 스텁, 더미와 같은 다양한 객체들을 의미하며 얻어지는 효과는 아래와 같다. 

- 테스트 대상 코드를 격리한다.
- 테스트 속도를 개선한다.
- 예측 불가능한 실행 요소를 제거한다.
- 특수한 상황을 시뮬레이션한다.
- 감춰진 정보를 얻어낸다.

#### 종류

##### Stub

원래의 구현을 최대한 단순한 것으로 대체하는 것, 아무런 기능이 없고 아무런 행위를 하지않는다.

테스트에서 대상 협력 객체에 대해서 아무런 관심이 없을 때 사용한다.

##### Fake Object 

원래 기능의 행위를 단순하게 모방함. 테스트간에 재사용이 가능하며 많은 테스트코드를 줄여주는 효과가 있다.

예를 들어서 `RedisCache` 클래스에서 Key/Value를 저장하거나 읽어오는 일은 Stub, Mock보다는 `FakeCache`를 구현하는 편이
훨씬 가독성에도 활용성도 좋을 수 있다.

##### Spy

행위에 대해서 **검증**하는 역할. 주로 아래와 같은 상황에서 사용한다. 

협력 객체에 대해서 
- 메서드 호출 여부 검증
- 메서드에 전달된 파라미터 값 검증
- 메서드 호출 횟수 검증

##### Mock

어떻게보면 Stub의 발전 형태도 띄는데, 예를 들어 stub으로 구현할 때 특정 조건에 의해서 어떤 값을 반환할지만 설정한다면,
Mock은 지정된 값이 들어오지 않은 경우 테스트를 실패시키거나 아무런 행위를 하지 않는 것, 호출할 때마다 다른 반환 값을
지정할 수도 있다.

Spy를 만들기위해 사용되기도 한다. Spy를 손수 하나씩 만들기에는 보통 중복되고 혹은 더 많은 코드를 요구하지만 Mock Library를
사용하다보면 행위 검증에 대해서 훨씬 쉽게 작성할 수 있는 장점이 있다. 아래는 주로 사용하는 C# 코드다


```csharp
doMock.Verify(d => d.Something(It.IsAny<string>()), Times.Onece);
```

#### 활용 지침

- 두 객체간 상호작용으로 특정 메서드 호출 여부를 알고 싶다면 `Mock`
- `Mock`으로 코드가 깔끔하게 정리되지 않는다면 `Spy`
- 협력 객체가 자리만 지키면 되고 응답 값을 테스트에서 통제 가능하다면 `Stub`
- 테스트 코드의 관리가 어려워지거나 시나리오가 복잡하다면 `Fake Object`
- 위 케이스에서 구분이 불가능하다면 동전을 던져서 선택해보자.

> Stub은 질문하고 Mock은 행동한다.

#### 준비하고, 시작하고 단언하라.

> AAA : Arrange-Act-Assert, GIVEN-WHEN-THEN

1. 준비 : 테스트 협력 객체 + 테스트 더블을 준비
1. 시작 : 실제 동작을 호출
1. 단언 : 반환 값이 옳바르고, 적절한 행위를 했는지 검증


#### 구현이 아니라 동작을 검증해라

---
## Part 2. Test Smell

### Chapter 4. 가독성

#### 기본 타입 단언 (Primitive Assertion)

의미를 알 수 없는 단어, 숫자(매직 넘버)에 가려진 상황. 아래 상황의 경우 **포함하고 있는 경우**를 `!= -1`의 indexOf 반환 타입을 통해서 유추할 수 있음. 이것은 추가적인 인지 부하가 생기므로 추상화된 메서드를 정의하거나 사용하는 편이 좋음.


```csharp
// What?
assertTrue(sentance.indexOf("CONTIAN_STRING") != -1);

// Fix
assertTrue(sentance.contains("CONTAIN_STRING"));
assertTrue(isContainsString(sentance, "CONTAIN_STRING"));
```

#### 광역 단언

너무 범위가 크게 단언하는 것, 테스트 케이스가 실패할 확률이 비교적 높고 하려고 하는 것이 무엇인지 알 수 없어 유지보수가 힘듦

##### 예시

```csharp
[Fact]
public void AdVenderParser_GetReport_WhenParametersIsValidated()
{
    // Given
    var parser = new FacebookReportParser();

    // When
    var report = parser.GetReports();

    // Then
    report.Should().NotBeNull().And.HaveAnyItems();
}
```

1. 파라미터가 유효한 것이 무엇을 의미하는지 전혀알 수 없음
2. `NotBeNull`은 어차피 `HaveAnyItems()`에서 확인할 수 없음
3. 네트워크 에러나 파서 버전 등 실패하는 이유가 너무 다양함.

SRP 원칙처럼 테스트가 실패하는 이유는 단 하나여야함. 하지만 위 예제에서는 테스트가 너무 많이 실패할 수 있고, 실제로 값이 반환된다고 하더라도 유의미한 결과 검증에 대해선 누락되어 있어 실패할 가능성이 높은 무의미한 테스트임.


##### 해결책

- 하나의 테스트를 상세하게 여러 테스트로 쪼갬. 아래와 같은 테스트를 예상할 수 있음.
    - 파라미터 검증 테스트
    - 리포트 값 검증 테스트
    - 리포트 갯수 테스트
- 의미 없는 단언 `NotNull` 혹은 다음 단언에서 확인이 가능한 단언은 하나로 축소하거나 다시 작성할 것.


#### 비트 단언

비트 단언의 경우 추상화의 수준이 너무 낮아 테스트의 의도나 의미를 파악하기 어려움

```csharp
[Fact]
public void PlatformBitTest()
{
    (Platform.IS_32_BIT ^ Platform.IS_64_BIT).Should().BeTrue();
}
```

`^`는 XOR연산자로 `A이거나 B`를 의미함. 즉 둘 다 다른 값인 경우에만 참인 논리 연산자. 하지만 대부분의 개발자의 경우 이 연산자를 쓰는 경우가 적고 의미가 저수준의 연산자에 가려진 상황이라 더 많은 인지부하가 필요한 테스트이다.

이를 아래와 같이 읽기 편하게 풀어쓸 수 있다.

```csharp
(Platform.IS_32_BIT || Platform.IS_64_BIT).Should().BeTrue();
(Platform.IS_32_BIT && Platform.IS_64_BIT).Should().BeFalse("Can't be 32bit and 64bit at the same time.");
```

#### 부차적 상세정보

테스트 코드에 테스트 내용과 관련없는 부수적인 정보가 넘쳐 흐르는 경우.

```csharp
[Fact]
public void Test()
{
    // Given
    var a = new Something(1);
    var b = new Something(2);
    var c = new Something(3);
    var d = new Something(4);
    var e = new Something(5);

    var composite = new CompositeSomething();
    composite.AddChild(a);
    composite.AddChild(b);
    composite.AddChild(c);
    composite.AddChild(d);
    composite.AddChild(e);

    // ....
}
```
위 예제에서 테스트를 위해 상황을 조합하는 코드는 실제로 테스트와는 크게 상관없는 코드. 이를 `[BeFore]` 혹은 생성자에 위임하는 것도 하나의 방법.

#### 다중 인격(Split Personality)

여러 테스트 목적이 하나의 테스트에 결합되어 있는 형태, 광역 단언과 다른 점은 단언 자체를 너무 크게하는 것과 여러가지 테스트 케이스를 길게 검증하거나 시나리오 형태로 검증하는 형태로 방법의 차이가 비교적 명확함.

이 경우 테스트 케이스를 여러개로 분리하고 하나의 테스트가 하나의 이유로 실패하도록 유도해야함

#### 쪼개진 논리

테스트 클래스는 한 곳에 있느나 오직 그 테스트 케이스를 위한 픽스쳐나 테스트 리소스가 다른 장소(파일)에 있는 경우 인지부하로 이어짐. 따라서 이를 한 곳으로 모아야함. 하지만 이는 상황에 따라서 안하는 것만 못한 경우가 있으므로 아래와 같은 가이드를 따를 것

1. 짧다면 통함
1. 통합하기 너무 길다면 팩토리 메서드나 테스트 데이터 생성기를 통해 제작
1. 위 방법 또한 쉽지 않다면 독립파일로 남겨둘 것

#### 매직 넘버

의미를 알 수 없는 단어 숫자에 가려진 상황, 예를 들면 아래 코드에서 `10`은 어떠한 정보로 전달하고 있지 않음.

```csharp
// When
var reports = reporter.GetReport();

// Then
reports.Should().HaveCount(10);
```

이를 해결하자면 의미 있는 숫자를 상수로 제공하거나 아래와 같이 읽기 좋게 만드는 방법이 필요함

```csharp
reports.Should().HaveCount(reportItem(10));
```

#### 셋업 설교

이전에 부차적인 상세 정보와 같이 테스트에서 실제로 관심이나 연관이 적은 맥랙 생성 코드를 셋업이나 생성자에 옮겨 테스트를 행위와 단언에 집중할 수 있도록 만들었다면 셋업 설교는 너무 상세하고 긴 준비작업을 의미함.

1. 셋업에서 핵심을 제외한 상세 정보는 private 메서드로 추출한다.
1. 알맞은 서술적 이름 사용
1. 셋업 내의 추상화 수준을 통일

예시 코드로 방법을 알아보자.

```csharp
public TestClass()
{
    _mockA = new Mock<IA>();
    _mockA
        .Setup(a => a.DoSomething())
        .Return(100);

    _mockB = new Mock<IB>();
    _mockB
        .Setup(b => b.DoSomething())
        .Return("RESULT OF B");

    _mockC = new Mock<IC>();
    _mockC
        .Setup(c => c.DoSomething())
        .Return(true);
}

// Fix

public TestClass()
{
    MockA();
    MockB();
    MockC();
}
```

#### 과잉보호 테스트

단언문에 도달하기 전까지 불필요한 중간 단계 단언문이 많이 등장하는 것, 어차피 실패할 테스트에 NullPointException을 방지하기 위해 NotNull임을 검증하거나 인덱스를 검사하거나 아이템을 가지고 있는지 여부를 검사하는 형태.

### Chapter 5. 유지보수성

#### 중복

중복에는 구조 중복과 상수 중복이 있으며 이를 둘다 메서드 추출이나 필드/상수 추출로 제거해야한다.

#### 조건부 로직

이름 자체는 문제가 없어보이지만 테스트 단언이 조건에 따라 분기가 되면 안된다는 내용, 조건부 로직을 가지는 이상 디버깅이나 테스트의 목적을 추측/이해하기 어려워지는 경햠이 나타남. 또한 경우에 따라선 테스트 케이스 자체가 명확하기 실행되지 않을 수 있음.

#### 양치기 테스트

간혈적으로 실패하는 테스트를 의미한다. 이는 주로 시간/OS/경쟁상태를 일으키는 쓰레드 사용 등과 같이 비결정적이고 제어가 불가능한 것에 의존하여 발생한다. 이를 회피하는 방법을 아래와 세가지이다. 절대, Thread::Sleep과 같은 메서드로 확률적으로 낮추지 말 것.

1. 회피한다. - 단언에 시간이나 쓰레드관련 한 내용을 제거한다.
1. 제어한다. - `ITimeProvider`과 같은 클래스를 사용하여 제어한다.
1. 격리한다. - 대상 코드에서 비결정적 의존을 제거한다.

#### 파손된 파일 경로

주로 혼자 개발하거나 인계 받은 코드에서 발생하는 냄새이며, 절대 경로인해 테스트 케이스가 꺠지는 것을 의미함.

- 상대경로 사용
- `Environment.PathSeperator`과 같은 구분자 사용

#### 끈질긴 임시 파일

테스트에서 결과용 혹은 프로세싱용 임시 파일을 사용하는 경우 최초 실행 이후의 테스트에서 문제가 발생할 수 있다.

- @Before 메서드에서 파일을 삭제할 것
- 가능하면 임시 파일명도 고유하게 지을 것. (랜덤하게)
- 파일이 있어야하는지를 명시할 것.

#### 잠자는 달팽이

다른 스레드가 완료되기를 기다리느라 Thread#sleep으로 긴 시간을 허비한 후에야 다음 단계를 진행하는, 아주 느린 테스트를 말함.
최초 몇 개 수준은 테스트 시간에 크게 작용하지 않지만 계속해서 쌓일 수록 테스트 속도가 계속해서 느려지는 경햠이 있음.

#### 픽셀 퍼펙션

그래픽스나 그래픽을 출력하는 코드를 검사하는 테스트가 풍기는 냄새. 픽셀단위로 단언하는 형태의 테스트를 지칭.
이는 렌더링 알고리즘이나, 테스트 리소스가 조금이라도 변해도 실제 사용에는 문제가 없지만 테스트가 실패하는 경우가 많음.

이를 해결하려면 알고리즘 기반으로 두 선이 연결이 되었는지 등과 같은 검사로 우회하는 방향이 옳바름.

#### 파라미터화된 혼란

파리미터된 테스트(Parameterized Test)는 테스트의 중복을 없애기에는 너무나도 좋은 패턴이지만, 테스트 셋이 복잡하거나 너무 광범위할 경우 오히려 역풍을 맞을 수 있다. JUnit의 경우에는 IDE상에서 파리미터된 테스트에 상세항목에 대해서 나타내지 않고 컴포지트된 형태로 보여주므로 실제로 어떤 케이스에서 실패했는지 알 수 없다.

1. 너무 복잡해졌다고 판단한 경우 사용하지 마라.
1. 각 케이스 별로 파라미터에 대한 설명이 들어간 추가 문자열을 제공하여 실패 테스트 케이스에서 바로 확인할 수 있도록 고칠 것.
1. 메서드와 언어적 특징을 통해서 좀 더 가독성 좋게 데이터를 만들 것.

#### 메서드간 응집력 결핍

테스트 클래스 하나에 속한 테스트 메서드들이 서로 다른 픽스쳐 객체를 사용한다는 것이다. 이는 테스트 클래스 하나가 응집력이 떨어진다고 볼 수 있고 또한 필드별 각 역할이 무엇인지, 어느 테스트가 어느 픽스처 객체를 사용하는지, 셋업에서는 어느 객체를 어떻게 설정해야하는 지 알기 어렵다.

1. 새로운 테스트 클래스를 만들어서 테스트 메서드 일부를 옮기고, 필요하다면 공통 로직을 담아둘 기반 클래스를 추출한다.
1. 별도 클래스가 제공하는 유틸리티 메서드를 이용해서 테스트 메서드 각자가 필요한 픽스처를 직접 생성한다.

### Chapter 6. 신뢰성

#### 주석으로 변한 테스트

주석으로 변한 코드는 그 즉시 가치가 상실되기 시작되어 시간이 지날수록 없는 코드가 됨. 주석이된 테스트코드를 발견했다면 해당 의미를 살펴보고 검증해본다. 끝끝내 알아낼 수 없다면 그 즉시 삭제할 것.

#### 오해를 낳는 주석

잘못된 주석은 오히려 코드 분석을 방해함.

1. 주석 대신 더 적절한 변수명이나 메서드명을 사용할 것
1. 주석으로 설명하려던 코드 블록을 메서드로 추출하고 알맞은 이름을 지어줄 것.

좋은 주석이란 코드가 그렇게 작성될 수 밖에 없던 당위성을 설명하는 주석. 이는 프로그래밍 언어의 문법만으로는 표현할 수 없는 영역. 그외는 모두 삭제나 리팩토링 대상.

#### 절대 실패하지 않는 테스트

```csharp
[Fact]
public void IncludeForMissingResourceFails()
{
    try
    {
        new Environment().Include("실존하지 않는 자원");
    }
    catch(IOException e)
    {
        assetThat(e.GetMessage(), Contains("실존하지 않는 자원"));
    }

    // 실패하는가?
}
```

위와 같은 테스트는 실패하는 케이스가 없다. 예외가 발생하지 않아도 성공하고 발생해도 성공한다. 이 경우 `Throw<Exception>`과 같은 단언문을 제대로 작성해야한다.
테스트를 작성할 때에는 성공하는 케이스를 먼저 작성하지 말고 실패하는지 체크해보는 것이 좋다.

#### 지키지 못할 약속

- 아무 '일'도 안하는 테스트
- 무언가 일은 하지만, 정작 '검증'은 전혀 하지 않는 테스트
- 이름값 못하는 테스트

마치 나중에 할 것처럼 하지 말자. 하거나, 안하거나 선택해야 대부분 좋은 상태를 유지할 수 있다.

#### 낮아진 기대치

실패해야하는 상황에서 실패하지 않는 테스트, 예를 들어 반환 값이 널이 아닌지만 단언하거나 집계값이 0이 이상인 것만 단언하는 경우 실제로 알고리즘이나 내용이 바뀌어도 테스트는 실패하지 않는다. 버그는 났는데 테스트망을 그냥 지나쳐온 경우가 발생할 수 있다.

#### 플랫폼 편견

특정 플랫폼에 편향되어 작성된 테스트, 예를들어 현재 플랫폼을 가져와 홈 디렉토리나 기본 다운로드 폴더 경로를 가져오는 테스트의 경우에는 실행되는 테스트 코드가 대상 플랫폼을 커버하지 못하고 있다면 에러가 발생할 확률이 높다. 이것은 현재 플랫폼이 아닌 대상 플랫폼 객체를 직접 만드는 방식으로 리팩토링하여 우회할 수 있다.

플랫폼 편견은 비교적 해결하기 힘든 문제 중 하나며 테스트 코드 뿐만 아니라 제품 코드를 리팩토링해야만 대부분의 문제가 해결된다.

#### 조건부 테스트

조건에 따라서 단언하는 테스트를 주로 조건부 테스트라고 하는데 이는 자칫 실패해야할 테스트를 성공하게 만들고 실제 성공 여부를 확신하지 못하게 만든다.

---

## Part 3. 여흥거리

### Chapter 7. 테스트 가능 설계

#### 테스트 가능 설계란?

> 당연하게도 코드를 더 잘 테스트할 수 있도록 해준다는 것.

##### 모듈러 설계?

제품의 기능을 뚜렷한 역할로 나누고 그 역할을 각각의 독립된 구성 요소에 맡기면 최종적으로 상당히 유연한 설계가 만들어지게 되며 이는 확장 - 축소에 유용하며 테스트에도 유연하게 구성된다. 이를 모듈러 설계라고 한다.

##### 단일 책임 원칙(Single Resposibility Principle) 

> 클래스를 수정해야하는 이유는 오직 하나뿐이어야한다 by 로버트 마틴 
> 메서드를 수정해야하는 이유도 오직 하나여야한다. 이것을 내면(Inside View)라 부른다. - 산드로 만쿠소

클래스는 작고 하나의 역할에만 충실해야한다. 이 이상 이 이하도 아니다.


##### 개방 폐쇄 원칙(Open Close Principle)

> 확장에는 열려있어야하며 수정에는 닫혀있어야한다. 

간혹 '확장'이라는 단어 덕분에 상속과 혼동할 수 있는데, 이는 어플리케이션 스코프의 이야기이다. 대표적으로 전략 패턴을 통해서 기존 코드의 수정없이 기능을 확장할 수 있다는 내용이다.

##### 리스코프 치환 원칙(Liskov Substitution Principle)

> 상위 클래스를 하위 클래스로 대체될 수 있어야 한다.

상위 클래스를 하위 클래스로 대체한다는 의미는 실제로 **변환(캐스팅)**을 의미하는 것이 아닌 기능적 대체가 가능하냐는 것이다. 즉, 상위 클래스에서 정의한 기능이 동일하게 하위 클래스에서도 동작하느냐라는 것이다. 상속 후 메서드를 오버라이딩 하거나 기존 메서드의 기능을 바꾸면 이를 지키고 있다고 보기 어렵다.

위 원칙을 지키면 계약 테스트가 가능하다.

##### 인터페이스 분리 원칙(Interface Segregation Principle)

> 하나의 범용 인터페이스보다 쓰임새별로 최적화한 인터페이스 여러개가 낫다.

SRP 처럼 인터페이스도 작고 클라이언트를 위해 최적화된 인터페이스 여러개로 구현되는 것이 유지보수에도 테스트에도 용의하다.

어떤 테스트를 위해서 범용 인터페이스의 가짜 객체를 만들기에는 너무 많은 비용이 들고 또한 구현 클래스들에게 사실 필요 없는 인터페이스의 기능임에도 구현을 강제할 수 있기 때문이다. 이는 오히려 `NotImplementedException`같은 익셉션이라도 발생한다면 프로그램의 큰 에러로 사용될 수 있다.

##### 의존 관계 역전 원칙(Dependency Inversion Principle)

> 구현에 의존하지 말고 추상 개념에 의존해라.

과하게는 모든 의존 인자는 추상 클래스, 인터페이스여야한다는 내용이며 이를 통해 얻을 수 있는 것은 테스트 및 확장 용이성이다. 

물론 과도한 확장 설계라고 할 수 있지만, TDD를 조금이라도 해본 사람은 기본적으로 구현엔 N개가 가능하다는 것을 알고 있을 것이다. Mock, Stub, FakeObject 모두 구현이기 때문이다.

#### 테스트 불가 원인

##### 클래스 생성 불가

좀 더 정확히는 클래스를 생성하는데 필요한 의존성을 우리가 제어할 수 없다는 것이 문제, 특히 라이브러리 클래스나가 의존에 걸려있다면 우리가 할 수 있는 일은 그리 많지 않다. 혹은 접근자가 너무 보수적이라거나, static 생성자에서 필드를 정의한다거나 하는 이유 때문에 우리는 대상 클래스를 생성하지 못한다.

##### 메서드 호출 불가

테스트 대상 메서드가 너무 커서 단위별로 테스트하려고 했던 메서드의 접근자가 private라거나, 인자 자체가 타입이 모호한 경우 `string`이거나 `IDictionary<Key, Value>`인 경우에는 실제로 어떻게 사용하고 있는지 데이터 베이스나 코드를 좀 더 깊이 이해하고 사용해야한다.

##### 결과 확인 불가

예를 들어서 어떤 Facade Method가 어떤 행위를 일련되게 하는 것이라고 생각해보자. 특정 메서드 내에서 객체를 생성하고 사용하고 리턴값은 `void`라면 이 메서드는 사실상 테스트할 수 있는 방법이 없다. 메서드에서 쓰레드를 생성한거나 하는 상황도 마찮가지다.

##### 협력 객체 대체 불가

위 처럼 협력 객체 생성 로직을 하드 코딩 해놓거나, 그 과정이 너무 복잡한 경우 테스트 작성 비용이 기하급수적으로 상승한다.

##### 메서드 오버라이딩 불가

`getCollaborator`과 같은 팩토리 메서드 패턴을 사용한 클래스에서 정작 해당 메서드가 `final`이나 `private`로 구현되어 있다면 해당 객체는 테스트가 불가능하다. 이를 대체할 수 있는 방법이 없기 때문이다.

#### 테스트 가능 설계를 위한 지침

1. 복잡한 private 메서드를 피하라
    - private 메서드는 public 메서드와 함께 테스트할 것
    - 만약 private method가 너무 커서 테스트하고 싶다면 역할이 너무 많으므로 리팩토링하라는 신호
1. final 메서드를 피하라
    - 시큐어 코딩 가이드의 내용은 만드는 제품이 라이브러리 및 제 3이 사용 솔루션이라면 모를까 온라인 서비스인 경우에는 거의 무의미하다. 이는 당신의 동료를 신뢰하지 못하고 있다는 것일 수 있다.
    - final이 테스트에 방해되는 경우, final로 선언해서 얻는 이득보다 작다고 판단되면 제거해라.
    - 성능 개선은 문제가 발생한 이후에 해라.
1. 정적 메서드를 피하라
    - 유틸리티 메서드를 정적 메서드로 만드는 것은 꽤나 좋은 선택
    - 하지만 결과가 일정하지 않고 임의성이 있다면 객체로 만들어 쓸 것
1. new 는 신중하게 사용하라
    - 다른 구현체로 바꿀 가능성이 있다면 외부에서 주입받아 사용할 것
    - 3자 라이브러인 경우 이를 감싼 다른 레이어를 만들어서 주입받을 것. 예를들면 S3 Client과 같은 경우 대체 방법이 없음.
1. 생성자에서 로직구현은 피해라
    - 생성자에서 로직구현은 대체할 수 있는 방법이 없다. 위와 마찬가지로 protected 나 다른 메서드로 변경하여 변경할 수 있도록 설계해야한다.
1. 싱글톤을 피하라
    - 교체가 어렵고 이를 의존하는 모든 객체는 테스트하기 어려워진다.
1. 상속보다는 컴포지션을 사용하라
    - 기능 재활용 목적이라면 상속은 적합하지 않다.
    - 대부분의 언어에서는 단일 상속을 지원하므로 다른 부모를 모실 기회를 잃어버리기 때문이다.
1. 외부 라이브러리를 감싸라
    - 라이브러리의 테스트 용이성을 확인해보자 만약 테스트가 용이하지 않다면(Fake, Test object를 만들기 어렵거나 불가능할 때) 그를 감쌓은 새로운 레이어를 만들어 대체해라.
1. 서비스 호출을 피하라
    - getInstance라던가 정확히는 어떤 서비스 객체를 가져오는 호출을 피해라. 이는 대체가 불가능하고 테스트하기 어려워진다.